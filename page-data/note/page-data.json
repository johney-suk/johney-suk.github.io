{"componentChunkName":"component---src-templates-post-jsx","path":"/note/","result":{"data":{"site":{"siteMetadata":{"title":"joni.blog"}},"markdownRemark":{"id":"c40ba638-e4ea-5a7e-b248-dc54603b1315","excerpt":"서론 소프트웨어 개발 초창기에는 기술을 습득하고 요구사항을 분석하고 이를 설계/구현하는 것만으로도 바쁘기 때문에 성능을 고려해서 개발하기가 쉽지 않다. 최근의 개발 환경이 스프링과 같은 개발 프레임워크 기반으로 많은 부분이 공통화되어 있기 때문에 성능과 관련해서 개발자가 직접 통제할 수 있는 영역이 매우 제한적이기 때문이기도 하다. 이러한 제약 사항과 패…","html":"<h2>서론</h2>\n<p>소프트웨어 개발 초창기에는 기술을 습득하고 요구사항을 분석하고 이를 설계/구현하는 것만으로도 바쁘기 때문에 성능을 고려해서 개발하기가 쉽지 않다. 최근의 개발 환경이 스프링과 같은 개발 프레임워크 기반으로 많은 부분이 공통화되어 있기 때문에 성능과 관련해서 개발자가 직접 통제할 수 있는 영역이 매우 제한적이기 때문이기도 하다.</p>\n<p>이러한 제약 사항과 패러다임의 변화에도 불구하고 성능은 소프트웨어나 서비스에 있어서 매우 중요한 요소이며 아무리 기능이 좋고 잘 만들어졌을지라도 원하는 성능이 나오지 않으면 서비스를 개통할 수 없게 되며 실제로 성능 문제가 발생해서 개통한 서비스를 다시 취소하는 경우도 많이 있다.</p>\n<p>웹 애플리케이션 성능 테스트 툴은 웹 애플리케이션을 운영하기전 성능, 안정성 및 확장성을 평가하는 데 필수이며, 잘알려진 테스트 툴은 Java 오픈소스 <code class=\"language-text\">Apache JMeter</code>,  Node.js 오픈소스 <code class=\"language-text\">Artillery</code>, 네이버에서 Grinder를 이용해서 대규모 엔터프라이즈 환경용으로 만든 <code class=\"language-text\">nGrinder</code>, <code class=\"language-text\">Gatling</code>가 있습니다.</p>\n<p>이 외에도 JavaScript 오픈소스 Grafana 통합을 통한 시각화를 제공하는 <code class=\"language-text\">k6</code>,  Python 오픈소스 <code class=\"language-text\">Locust</code> 등 각각의 특징과 장점을 가지고 있어, 사용 목적과 환경에 따라 선택하여 사용되고 있습니다. </p>\n<blockquote>\n<p>최근 운영을 앞두고 있는 프로젝트의 웹 어플리케이션 성능 테스트를 진행하면서 웹 애플리케이션 성능 테스트 툴로 Java 오픈소스 <code class=\"language-text\">Apache JMeter</code>를 선택하였고 선택하게된 이유와 분석 내용을 포스팅 하겠습니다.</p>\n</blockquote>\n<h2>부하 테스트</h2>\n<p>간단히는 10분에서 1시간 정도 테스트해서 초당 평균 TPS와 하드웨어 및 네트워크 사용률을 분석한다. 추가적으로 1일에서 1주일 동안 지속적으로 부하르 발생시켜서 부하가 지속적으로 처리되는지도 확인한다. 장시간 부하 테스트 시 가용성 테스트를 병행한다.</p>\n<p>성능테스트를 수행할 경우 얻을 수 있는 이점은 다음과 같다.</p>\n<ul>\n<li>개발한 소프트웨어가 특정한 하드웨어에서 얼마나 많은 트랜잭션 혹은 사용자의 요청에 대응할 수 있는지 확인할 수 있다.</li>\n<li>성능 테스트를 통해 소프트웨어 혹은 하드웨어상에 존재하는 병목 구간과 문제 구간을 유추할 수 있다.</li>\n<li>개발한 서비스를 개통할때 얼마나 많은 사용자에게 서비스가 가능한지 사전에 예측하고 준비한다.</li>\n<li>성능 테스트 시 발생하는 각종 로그 데이터, 업무 데이터, 파일 등의 발생량을 고려하여 시스템의 스토리지, 디스크, 데이터베이스, 메모리 등의 사용량을 예측할 수 있고 향후 서비스 운영시 참조할 수 있는 기준값을 산출할 수 있다.</li>\n<li>테스트 활동을 통해 서비스를 개발하는 개발자, 기획자 및 관리자에게 항상 성능을 고려해서 기획, 설계, 개발해야 한다는 인식을 심어줄 수 있다.</li>\n</ul>\n<h2>성능 테스트 전략 수립</h2>\n<p>성능 테스트 전략 수립은 성능 테스트에 대한 목표를 정의하는 것부터 시작한다. 목표가 없는 테스트는 흐지부지 끝날 가능성이 많기 때문에 객과적인 기준에 따라 전략을 세우고 그 전략에 따라 지속적이고 반복적으로 성능 테스트를 하는 것 중요하다.</p>\n<h3>1. 목표 수립</h3>\n<p>성능 테스트 전략 수립 단계 중 가장 핵심은 바로 서비스할 소프트웨어에 대한 명확한 목표를 수립하는 것이다. 이 목표를 달성하기 위해 성능 테스트와 부하 테스트를 수행하고 튜닝작업을 진행한다. 만일 튜닝을 해도 목표를 달성하지 못한다면 하드웨어 증설이나 아키텍처 변경을 고려해 볼 필요가 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">목적</code></p>\n<ul>\n<li>성능 테스트의 목적을 명확하게 기술한다 (새로 구축하는 소프트웨어가 목표로 하는 부하 상황에서 원활하게 작동하는지를 확인하거나 신규 도입하는 하드웨어가 개발된 소프트웨어를 기반으로 최대 어느정도까지 서비스가 가능한지 확인한다.)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">목표</code></p>\n<ul>\n<li>목적이 정의되었다면 목적에 기반한 목표를 정의한다. 목표는 매우 상세하게 기록하는 것이 좋은데 동시 사용자 수, 동시 사용자가 발생시키는 요청수 등의 예측치를 기술하는 것이 좋다. (화면 로그인의 최대 피크 타임을 오전 8시부터 9시 사이로 예상한다면 해당 시간 동안 초당 100번의 SSO 서비스가 가능해야 한다.)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">대상</code></p>\n<ul>\n<li>\n<p>성능 테스트는 가능한 한 모든 서비스에 대해서 최대한 많이 하면 좋지만, 시간이 많이 들고 노력도 많이 필요한 작업이다. 때문에 성능 테스트의 목적과 목표를 검증할 수 있는 대표 서비스를 도출해서 수행하는 것이 좋다. 소프트웨어에서 제공하는 서비스 중 대표적으로 많이 사용하는 것과 반드시 검증해야 하는 서비스를 도출하되 전체 서비스의 20%를 넘지 않는 선에서 수행하는 것이 좋다 </p>\n<blockquote>\n<p>성능 테스트에서 황금률은 전체 20%의 서비스가 전체 자원의 80%를 소모한다는 법칙이 있는데 많은 서비스를 테스트한다고 해도 성능 검증에 큰 영향을 주지 않는 경우가 많다.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>목적/목표/대상을 수립했다면, 이에 대한 기준을 세워야 하는데 가장 좋은 기준은 이미 해당 서비스를 하고 있는 경우이다. 이 경우 현재 서비스의 상태와 총 사용자 수, 특정 시간대의 동시 사용자수, 그리고 초당 평균 요청 수 등을 뽑고 이 값을 기준으로 향후 어느 정도의 부하를 감당해야 하는지 정의하면 좋다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">총 사용자수</code></p>\n<ul>\n<li>서비스를 사용하고 있느 혹은 사용할 예정인 전체 사용자 수를 정의한다. 사용자는 잠재적으로 서비스에 부하를 발생시키고 성능에 영향을 주는 주요한 항목이다. 현재 서비스의 가입자 항목, 가입은 하지 않았지만 '손님'과 같은 형태로 사용하는 경우도 모두 도출하는 것이 좋다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">동시 사용자수</code></p>\n<ul>\n<li>총 사용자 수보다 더 중요한 항목이 바로 동시 사용자 수다. 동시 사용자 수에 대한 정의는 다소 애매한 부분이 있는데, 주로 특정 시간 동안 서비스를 요청하는 사용자 수를 의미한다. 대부분 특정 시간대(피크 타임)의 1초 동안 서비스를 요청하는 사용자 수로 정의하며 정확한 집계가 어렵다면 웹서버나 WAS의 ACCESS 로그에 찍히는 IP 정보와 시간을 분석해서 도출한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">평균 TPS</code></p>\n<ul>\n<li>TPS는 초당 요청 횟수를 의미하며 성능 테스트시 가장 보편적으로 사용하는 수치이다. 이 역시 동시 사용자수와 마찬가지로 피크 타임 때의 로그를 분석해서 평균 TPS를 수집하는데, 이때 주의할 것은 단순한 HTML이나 이미지 파일 등 미들웨어나 데이터 베이스에 큰 영향을 주지 않는 요청은 제외시키는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n<p>현행 성능 기준 정보를 바탕으로 목표에 대한 값과 대상을 산출하게 되며 향후 5년간 서비스의 발전을 고려해서 최종 성능 테스트 도달 목표를 정의하는 것이 좋다. 예를 들어 현재 동시 사용자가 100명이고 평균 TPS가 2000인데 해당 비즈니스가 매년 20%씩 증가한다고 가정한다면 이를 기준으로 5년 후의 동시 사용자와 평균 TPS를 산정하는 것이다.</p>\n<p>위 설명들은 이미 서비스가 제공되고 있어서 서비스 업그레드나 하드웨어 업그레이드, 혹은 개편 시에 기존 서비스를 기반으로 성능 테스트 기준 정보를 산출하는 것이다. 그런데 신규로 만들고 있는 서비스라면 이를 도출하기가 매우 어렵다. 이러한 경우는 목표를 잡을때 다소 추상적으로 잡을 수 밖에 없고 테스트할 대상도 좀 더 많이 정의해야 한다.</p>\n<h3>2. 구간별/대상별 목표 수립</h3>\n<p>앞서 설정한 목표는 성능 테스트에 사용할 상위 수준의 목표이며 해당 항목들이 정의되면 이제 상세 목표를 수립해야 한다. 상세 목표를 수립할 때는 구간별 목표와 대상별 목표를 정의해야 한다. 일반적인 웹기반 프로젝트에서는 미들웨어에서의 성능 수치, 데이터베이스의 성능 수치, 대내/대외 연계를 위한 성능 수치, 최종적으로 네트워크의 성능 수치를 고려해야 한다. 이러한 구간별 목표는 클라이언트의 요청부터 응답까지 수행되는 각 구간을 사전에 정의하고 구간에 따른 누적 수치를 산출하게 되는데 중요한 것은 구간별로 수치값을 측정할 수 있는 환경이 마련되어 있어야 한다는 점이다.</p>\n<p>JMeter에서의 성능 테스트는 클라이언트의 요청과 응답을 기준으로 측정하기 때문에, 구간별 측정 방법이 제공되지 않으면 어떤 서비스의 어떤 구간에서 문제가 발생했는지 알 수가 없다.</p>\n<p>구간별 목표가 정의되었다면 성능 테스트 대상 서비스별 목표 수립이 필요하다. 동일한 소프트웨어에서 제공하는 서비스라도 서비스의 성격에 따라 목표가 달라지기 때문이다.</p>\n<ul>\n<li>\n<p>로그인 업무</p>\n<ul>\n<li>주로 업무가 시작되는 시간에 집중적으로 부하가 발생한다. 아침 출근 한시간 전부터 출근 후 한 시간이 가장 피크타임이다. 그리고 점심시간 이후 오후 근무 시작 시점붙터 한시간 역시 로그인이 가장 많은 부하를 받는다.</li>\n</ul>\n</li>\n<li>\n<p>공통 업무</p>\n<ul>\n<li>업무마다 공통적으로 호출되는 기능의 경우 응답 시간은 매우 빠르지만 워낙 호출되는 트랜잭션 수가 많기 때문에 최대한의 성능 튜닝 및 사전 검증이 필요하다.</li>\n</ul>\n</li>\n<li>\n<p>통계 업무</p>\n<ul>\n<li>통계 화면은 주로 오전 시간대에 많은 부하가 발생한다. 전날 혹은 전월 통계를 기반으로 금일 작업 계획을 세우기 때문이다. 상대적으로 오후에는 부하가 급격히 떨어진다.</li>\n</ul>\n</li>\n</ul>\n<p>최근에는 글로벌 기업이 늘고 글로벌 서비스가 많아지면서 부하가 발생하는 특정 시간대를 규정하기가 어려운 경우도 많다. 그러므로 목표로 하는 서비스 상황을 고려해서 성능을 테스트할 서비스를 도출하고 각각에 대한 목표 수치를 수립할 필요가 있다. </p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://www.redline13.com/blog/2019/05/jmeter-thread-count/\">https://www.redline13.com/blog/2019/05/jmeter-thread-count/</a></li>\n<li><a href=\"https://12bme.tistory.com/503\">https://12bme.tistory.com/503</a></li>\n</ul>","frontmatter":{"title":"[Spring] JMeter 사용법","date":"June 12, 2024","update":"June 12, 2024","tags":["Spring","JMeter"],"series":"부하 테스트 feat.JMeter"},"fields":{"slug":"/note/","readingTime":{"minutes":15.835}}},"seriesList":{"edges":[{"node":{"id":"c40ba638-e4ea-5a7e-b248-dc54603b1315","fields":{"slug":"/note/"},"frontmatter":{"title":"[Spring] JMeter 사용법"}}},{"node":{"id":"4cae0647-cbdb-598b-891a-d4bf85aadee8","fields":{"slug":"/JMeter/"},"frontmatter":{"title":"[Spring] JMeter 사용 후기"}}}]},"previous":{"fields":{"slug":"/note/"},"frontmatter":{"title":"[정리] Redis 실무에 사용하면서 공부한 내용"}},"next":{"fields":{"slug":"/JMeter/"},"frontmatter":{"title":"[Spring] JMeter 사용 후기"}}},"pageContext":{"id":"c40ba638-e4ea-5a7e-b248-dc54603b1315","series":"부하 테스트 feat.JMeter","previousPostId":"c543d984-bc36-5b39-97ba-2bf76ca38e89","nextPostId":"4cae0647-cbdb-598b-891a-d4bf85aadee8"}},"staticQueryHashes":[],"slicesMap":{}}