{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"JMeter란? JMeter란? Apache JMeter는 웹 애플리케이션 및 다양한 프로토콜에 대해 부하 테스트와 성능 측정을 수행할 수 있는 오픈 소스 도구입니다. GUI 기반의 사용이 편리한 인터페이스를 제공하며, HTTP, HTTPS, FTP, JDBC, JMS, SOAP, REST 등 다양한 프로토콜을 지원한다. JMeter는 분산 테스트, 스크…","fields":{"slug":"/JMeter/"},"frontmatter":{"date":"July 04, 2024","title":"[Spring] JMeter으로 부하테스트 하기","tags":["Spring","JMeter"]},"rawMarkdownBody":"\r\n## JMeter란?\r\n![JMeter란?](./1.PNG)\r\n\r\nApache JMeter는 웹 애플리케이션 및 다양한 프로토콜에 대해 부하 테스트와 성능 측정을 수행할 수 있는 오픈 소스 도구입니다. GUI 기반의 사용이 편리한 인터페이스를 제공하며, HTTP, HTTPS, FTP, JDBC, JMS, SOAP, REST 등 다양한 프로토콜을 지원한다. JMeter는 분산 테스트, 스크립트 기반 자동화, 확장 가능한 플러그인, 그리고 다양한 리포팅 및 분석 기능을 제공하여 웹 애플리케이션의 성능을 종합적으로 테스트할 수 있다.\r\n\r\n## JMeter 실행 방법\r\ncmd -> 압축푼 폴더 아래 bin 폴더로 이동 -> jmeter 실행\r\n> ex) D:\\apache-jmeter-5.6.3\\bin\r\n\r\n![JMeter 실행방법 1.cmd](./2.PNG)\r\n\r\n아래와 같은 GUI 가 나온다.\r\n![JMeter 실행방법 2.Apache JMeter](./3.PNG)\r\n\r\n## JMeter 테스트\r\n\r\n### JMeter 테스트 환경 유의사항\r\n테스트 환경 분리해야한다. 실제 운영 환경과 테스트 환경을 분리하여 테스트 툴 JMeter와 테스트 대상 웹 어플리케이션이 사용하는 메모리 등 영향을 최소화 한다.\r\n\r\n### JMeter 테스트 용어 정리\r\n|항목|내용|\r\n|-|-----|\r\n|Thread Group|테스트에 사용될 쓰레드 개수, 쓰레드 1개당 사용자 1명\r\n|Sampler|사용자의 액션 (예: 로그인, 게시물 작성, 게시물 조회 등)\r\n|Listener|응답을 받아 리포팅, 검증, 그래프 등 다양한 처리\r\n|Configuration|Sampler 또는 Listener가 사용할 설정 값 (쿠키, JDBC 커넥션 등)\r\n|Assertion|응답 확인 방법 (응답 코드, 본문 내용 비교 등)\r\n\r\n\r\n### 1. Test Plan 생성\r\nFile -> New -> Test Plan Name 설정\r\n\r\n![JMeter 테스트 1. Test Plan 생성](./4.PNG)\r\n\r\n### 2. Thread Group\r\n테스트 쓰레드, 쓰레드 개수를 만드는데 소요되는 시간, 요청 횟수를 설정한다.\r\n\r\n방금 만든 테스트에 오른쪽 클릭 -> Add -> Threads (Users) -> Thread Group\r\n\r\n![JMeter 테스트 2. Thread Group](./5.PNG)\r\n\r\n \r\n![JMeter 테스트 2. Thread Group - ](./6.PNG)\r\n\r\n#### Action to be taken after a Sampler error\r\n\r\nAction to be taken after a Sampler error에서 Error가 리턴됐을 때 어떻게 할 건지에 대한 설정을 할 수 있다.\r\n\r\n|항목|내용|\r\n|-|-----|\r\n|Continue|오류가 발생해도 JMeter는 현재 스레드 그룹의 다음 샘플러를 계속 실행. 오류는 로그에 기록되지만, 이후 샘플러의 실행에는 영향을 미치지 않음\r\n|Start Next Thread Loop|오류가 발생하면 현재 스레드 루프를 중단하고, 스레드 그룹 내의 다음 루프 반복을 시작. 이는 루프 컨트롤러나 스레드 그룹의 루프 카운트를 기반\r\n|Stop Thread|오류가 발생한 스레드만 중지. 이 옵션을 선택하면 해당 스레드의 모든 샘플러 실행이 중단\r\n|Stop Test|오류가 발생하면 전체 테스트가 즉시 중지됩니다. 모든 스레드와 샘플러의 실행이 중단\r\n|Stop Test Now|\"Stop Test\"와 유사하지만, 이 옵션은 테스트를 가능한 한 빨리 중지. 모든 현재 실행 중인 샘플러를 강제로 중단시키고 즉시 종료\r\n|Abort Test|테스트 실행을 즉시 중단하고 JMeter를 종료합니다. 이는 긴급 상황에서 사용되며, 모든 스레드와 샘플러가 즉시 중단\r\n\r\n#### Thread Properties\r\n\r\n5명의 유저가 1초만에 2번 반복해서 에러가 발생해도 계속 요청을 보낸다고 설정\r\n\r\n\r\n|항목|내용|\r\n|-|-----|\r\n|Number of Threads|테스트에 사용할 가상 사용자(쓰레드)의 수를 설정\r\n|Ramp-up period|쓰레드 개수를 만드는데 소요되는 시간\r\n|Loop Count| 각 스레드가 테스트 계획을 몇 번 반복할지를 설정\r\n\r\n\r\n### 3. Sampler\r\n\r\nThread Groupd이 해야할 행동을 정의하는 샘플이다.\r\n\r\nThread Group 우클릭 -> Add -> Sampler -> HTTP Request 클릭\r\n\r\n![JMeter 테스트 3. Sampler](./7.PNG)\r\n\r\n테스트로 통신을 시도한 Controller를 기준으로 기입\r\n\r\n![JMeter 테스트 3. Sampler- settings](./8.PNG)\r\n\r\n### 4. Listener\r\nSampler가 받아오는 리턴 값을 바탕으로 그래프, 레포팅을 만들어주는 Listener를 설정\r\n\r\n### 5. Timers\r\nJMeter의 테스트 플랜에 샘플러를 등록하면 순차적으로 진행이 되지만 현실 세계에서 하나의 사용자가 요청을 순차적으로 매우 빠른 시간내에 수행하는 것은 불가능하다. 이처럼 요청과 요청 사이에 특정한 시간 간격을 두려면 Timers를 이용해서 설정할 수 있다.\r\n \r\n### 6. Assertion\r\nJMeter의 HTTP 프로토콜을 이용해서 성능 테스트를 할 경우 요청별 성공/실패 여부는 HTTP 응답 코드의 값을 이용해서 판단한다. HTTP 응답 코드가 200이면 성공을, 그외에 다른 코드 값은 실패로 규약되어 있다. JMeter에서도 이를 그대로 사용하며 200번 코드가 리턴되면 테스트는 성공으로 인식한다.\r\n하지만 업무적으로 200번 코드가 리턴되더라도 실패로 판단해야 하는 경우도 많이 있다. 이 경우 Assertion를 이용해서 응답 정보에 특정한 메시지를 필터링해서 성공/실패 여부를 판단할 수 있다.\r\n\r\n### 7. Configuration Elements\r\nConfiguration Elements는 샘플러와 밀접한 관련이 있다. 비록 직접적으로 요청을 수해하지는 않지만 샘플러의 요청 정보를 관리할 수 있다. 예를 들어 테스트 플랜이 복잡해서 HTTP Request Sampler 작성을 많이 해야 하는데, 서버 IP나 포트 등 공통적으로 많이 사용되는 부분이 있다면 Configuration Elements의 \"HTTP Request Defaults\"에 설정하면 된다. 그러면 해당 설정 정보가 관련된 HTTP Request에 모두 적용된다.\r\n\r\n### 8. Pre-Processor Elements\r\n샘플러를 실행하기 전에 수행해야 할 내용을 정의한다. 예를 들어 요청을 하기 전에 파라미터 값을 초기화하는 등의 작업에 사용한다.\r\n\r\n> 위 항목들은 JMeter 실행시 우선순위가 존재하는데, 다음과 같다.\r\nConfiguration -> Pre-Processor -> Timer -> Sampler -> Post-Processor -> Assertions -> Listener\r\n\r\n\r\n## Test Scenario\r\n\r\n10s 동안 IP에서 받을 수 있는 최대 콜수를 선택하기 위한 기준으로 \r\n2500Thread, 3000Thread, 5000Thread, 10000Thread 총 4가지 경우로 테스트 진행했고,실제 운영 시 호출하는 콜수를 알 수 없기 때문에 임시로 서버 처리 성능 기준만으로 선정하여 테스트 실시했다.\r\n\r\n## 테스트 진행간 Loop Count와 Thread Count 혼란\r\n`시나리오 1 : number of thread 수가 10 인 경우 ramp-up 시간은 10이고 loop count는 1`\r\n\r\n`시나리오 2 : number of thread 수가 1이면 ramp-up 시간은 1이고 loop count는 10`\r\n두 시나리오의 차이점은 무엇이며 성능에 비슷한 영향을 끼칠까? 시나리오 2에서 요청 사이의 지연은 얼마일까?\r\n\r\n시나리오 2에서 모든 스레드가 활성 상태로 유지될까?\r\n\r\n스레드가 사용자를 시험하고 루프 카운트는 스레드가 요청을하는 횟수를 의미한다는 알고있다.\r\n\r\n그럼 차이를 생각 해보면, 시나리오 1에서는 10 개의 스레드가 사용되고 ramp-up period은 10 초이므로 JMeter는 10 개의 스레드를 모두 기동하고 실행하는 데 10 초가 걸리게되고\r\n\r\n각 스레드는 이전 스레드가 시작된 후 1 초 (10을 10으로 나눈 값)마다 시작된다.\r\n\r\n​\r\n30 개의 스레드가 있고 120 초의 램프 업 기간이있는 경우 각 연속 스레드는 4 초 지연된다.\r\n\r\n\r\n시나리오 2에서 JMeter는 1 개의 스레드를 실행하고 하나의 스레드가 완료되면 다음 스레드가 시작되고 10 번 반복됩니다.\r\n\r\n\r\n몇 가지 세부 사항을 명확히 해보자. 두 시나리오 모두에서 10 개의 스레드가 생성됩니다. 시나리오 2에서 새 스레드가 시작되면 이전 스레드가 살아 있을것이다.\r\n\r\n이 둘의 차이점은 시나리오 1에서 스레드는 병렬로 작동 할 수 있으며 시나리오 2에서 각 스레드는 이전 스레드가 중지 된 후 시작됩니다. 그리고 지정하지 않는 한 스레드간에 지연이 없다.\r\n​\r\n\r\n따라서 결국 시나리오 2에서는 하나의 1 스레드 만 살아 있고 시나리오 1에서는 모든 스레드가 살아 있다.\r\n\r\n\r\n## 참고\r\n\r\n- https://www.redline13.com/blog/2019/05/jmeter-thread-count/\r\n- https://12bme.tistory.com/503\r\n- https://jmeter.apache.org/usermanual"},{"excerpt":"서론 작년 실무에서 진행된 메신저 개발에서 프로젝트의 모바일 연동 및 로 구축 업무를 인수인계를 받으며 세션 관리, 실시간 메시지 전달, 채팅 히스토리 저장, 온라인 상태 관리, 분산 캐시 등 다양한 용도로 Redis 활용하였고, 프로젝트 진행 과정에서 정리한 Redis 개념과 동작 원리를 포스팅하겠습니다. Redis란? Redis(Remote Dicti…","fields":{"slug":"/note/"},"frontmatter":{"date":"June 12, 2024","title":"[정리] Redis 실무에 사용하면서 공부한 내용","tags":["DataBase","Redis"]},"rawMarkdownBody":"\r\n## 서론\r\n작년 실무에서 진행된 메신저 개발에서 프로젝트의 모바일 연동 및 `온프레미스(On-premise)`로 구축 업무를 인수인계를 받으며 세션 관리, 실시간 메시지 전달, 채팅 히스토리 저장, 온라인 상태 관리, 분산 캐시 등 다양한 용도로 Redis 활용하였고, 프로젝트 진행 과정에서 정리한 Redis 개념과 동작 원리를 포스팅하겠습니다.\r\n\r\n## Redis란?\r\n\r\nRedis(Remote Dictionary Storage,레디스)는 모든 데이터를 메모리에 저장하고 조회하는 in-memory DB, 모든 데이터를 메모리로 불러와서 처리하는 메모리 기반의 key-value 구조의 데이터 관리 시스템(DBMS)이다. 일종의 NoSQL이다.\r\n>이런 기술을 위해 Redis 가 존재하고 누군가는 Redis 를 캐싱 솔루션이라고 부르기도 하고 누군가는 NoSQL 의 `Key-Value 저장소`라고 부르기도 한다.\r\n\r\n## Key-Value 저장소 이해\r\nkey-value 구조 데이터란, mysql 같은 관계형 데이터가 아닌 비 관계형 구조로서 데이터를 그저 '키-값' 형태로 단순하게 저장하는 구조를 말한다.\r\n\r\n>장점은 데이터의 고속 읽기와 쓰기에 최적화, 단점은 쿼리 연산을 지원 X\r\n\r\n![키-값 데이터 저장소의 간단한 예](./1.PNG)\r\n\r\n## 인 메모리(In-Memory) 저장 방식\r\n레디스는 데이터를 저장하는 공간이 특별합니다. 일반적으로 mysql, oracle 등의 RDB들이 하드디스크에 데이터를 저장하고 관리하는 것과는 달리 레디스는 데이터를 주기억장치인 ram, 즉 In-memory에서 관리된다.\r\n\r\n## 인 메모리(In-Memory) 저장 방식의 문제점\r\nredis의 in memory 저장 방식은 빠르기도 하지만 DB 서버에 장애가 발생할 경우 또는 서버 전원이 갑자기 꺼지면 안에 있는 데이터들이 삭제된다. 그래서 보통은 로그인 세션 같은, 서버가 꺼져서 날아가도 상관 없는 임시 데이터에 주로 쓰인다. 그리고 대부분 속도의 장점으로 사용되기 때문에 압축은 하지 않으며, 데이터에 비해 RAM 용량이 넉넉하지 않을 경우 가상 메모리를 쓰게 되어 역효과가 일어나기도 한다.\r\n\r\n해당 저장 방식의 문제점과 시스템의 안정성을 위해 보완을 해야할 방법에대해서 정리한 글 => <br> [Persist Option 데이터 영구 저장하기](../persistence/index.md)\r\n\r\n## Redis의 주요 특성\r\n### Redis 용어 정리\r\n\r\n|항목|내용|\r\n|-|-----|\r\n|Key-Value 스토어|Key-Value 를 저장할 수 있는 스토리지를 지원한다.|\r\n|컬렉션 지원\t|List, Set, Sorted Set, Hash 등의 자료구조를 지원한다.|\r\n|Pub/Sub 지원|Publish/Subscribe 모델을 지원한다.|\r\n|디스크 저장(Persistent Layer)|현재 메모리의 상태를 디스크로 저장할 수 있는 기능과 현재까지의 업데이트 내용을 로그로 저장할 수 있는 AOF 기능이 있다.|\r\n|복제(Replication)|다른 노드에서 해당 내용을 복제할 수 있는 Master/Slave 구조를 지원한다.|\r\n|복제(Replication)|이상의 기능을 지원하면서도 초당 100,000 QPS(Queries Per Second) 수준의 높은 성능을 지원한다.|\r\n\r\n+ Key-Value 스토어\r\n  - 기본적으로 Redis 는 Key-Value 스토어로 빠르고 간단하게 데이터를 가지고 올 수 있다.\r\n+ 컬렉션 지원\r\n  - Redis 는 여러가지 자료구조를 지원하므로 서비스에 맞는 설계를 할 때 유용하게 사용될 수 있다.\r\n+ 디스크 저장\r\n  - Redis 의 특징 중 하나는 현재 메모리의 상태를 디스크에 스냅샷 형태로 남길 수 있는 RDB 방식이 있다. 그러므로 Redis 를 restart 할 때 스냅샷에 있는 내용을 가지고 쉽게 복구할 수 있고, AOF(Append Only File) 형태로 Redis 에 변경 내역들을 모두 남기는게 가능해서 Write Behind 같은 기능을 지원하는 것도 가능하다.\r\n+ 복제\r\n  - Redis 는 Master/Slave 구조로 이용할 수 있어서 Master 의 읽기 부하를 Slave 로 나누는게 가능하다.\r\n+ 빠른 성능\r\n  - Redis 를 이용하는 가장 큰 이유는 성능이다. 초당 50,000 ~ 60,000 이상의 처리 속도가 필요하다면 어쩔 수 없이 Redis 나 Memcached 를 이용해야한다.\r\n\r\n## Redis와 비교대상 Memcashed\r\nMemcahed와 Redis와 비교대상으로 질문이 많은데 이젠에 살펴본 후 머릿속에 남아있던 기억은 사실상 Redis가 더많은 기능을 제공하고있고 단순히 Memcahed에 비해 Redis가 추가적으로 제공하는 기능이 많았다고 기억하고 있습니다.\r\n블로그를 작성하게되면서 더욱 자세히 알게되었고 리마인드하며 내용을 정리 했습니다.\r\n\r\n```\r\nMemcached 는 캐싱 솔루션이고 Redis 는 저장소의 개념까지 추가된 것 입니다.\r\n```\r\n캐싱이란 말은 빠른 응답을 위해 결과를 저장해주는 솔루션을 말하고 언제든지 사라져도 상관없습니다. 하지만 저장소의 개념은 데이터가 보존되어야 한다는 의미입니다. 그래서 Redis 는 RDB 나 AOF 같은 기능을 지원하기도 합니다.\r\n\r\n그리고 추가로 Redis 는 Memcached 에 없는 여러가지 자료구조를 지원해서 개발자의 생산성을 높여주는 일도 해줍니다.\r\n\r\n### Redis 와 Memcached 의 장단점 비교\r\n\r\n|기능|Redis|Memcached|\r\n|-|-----|----|\r\n|속도|초당 100,000 QPS 이상|초당 100,000 QPS 이상|\r\n|자료구조|List, Set, Sorted Set, Hash 지원|Key-Value 만 지원|\r\n|안정성|특성을 잘못 이해할 경우에 장애가 발생할 수 있다.|장애가 거의 없다.|\r\n|응답 속도의 균일성|Memcached 에 비해서 응답속도의 균일성이 떨어질 수 있다.|전체적으로 응답속도는 균일하다.|\r\n\r\n응답 속도의 균일성 같은 경우가 Redis 와 Memcached 가 차이나는 이유는 메모리 할당 구조가 다르기 떄문인데 Redis 같은 경우는 Jemalloc() 을 사용해 메모리 할당을 하고 free() 를 통해서 메모리 할당을 지웁니다. 반면에 Memcached 는 slab 을 통해서 일정한 사이즈의 메모리를 균일하게 1MB 의 페이지로 자르고 그 안에 또 작은 사이즈 부터 큰 사이즈의 chunk() 를 일정하게 놔두는 식을 이용해 메모리 내부 단편화 현상은 있지만 외부 단편화 현상을 없도록 해서 메모리 관리를 조금 더 효율적으로 이용할 수 있어서 응답 속도가 비교적 균일합니다.\r\n\r\n\r\n## 다음\r\n[Persist Option 데이터 영구 저장하기](../persistence/index.md)"},{"excerpt":"서론 소프트웨어 개발 초창기에는 기술을 습득하고 요구사항을 분석하고 이를 설계/구현하는 것만으로도 바쁘기 때문에 성능을 고려해서 개발하기가 쉽지 않다. 최근의 개발 환경이 스프링과 같은 개발 프레임워크 기반으로 많은 부분이 공통화되어 있기 때문에 성능과 관련해서 개발자가 직접 통제할 수 있는 영역이 매우 제한적이기 때문이기도 하다. 이러한 제약 사항과 패…","fields":{"slug":"/note/"},"frontmatter":{"date":"June 12, 2024","title":"[부하테스트] 부하 테스트 시작하기","tags":["부하테스트","JMeter"]},"rawMarkdownBody":"\r\n## 서론\r\n소프트웨어 개발 초창기에는 기술을 습득하고 요구사항을 분석하고 이를 설계/구현하는 것만으로도 바쁘기 때문에 성능을 고려해서 개발하기가 쉽지 않다. 최근의 개발 환경이 스프링과 같은 개발 프레임워크 기반으로 많은 부분이 공통화되어 있기 때문에 성능과 관련해서 개발자가 직접 통제할 수 있는 영역이 매우 제한적이기 때문이기도 하다.\r\n \r\n이러한 제약 사항과 패러다임의 변화에도 불구하고 성능은 소프트웨어나 서비스에 있어서 매우 중요한 요소이며 아무리 기능이 좋고 잘 만들어졌을지라도 원하는 성능이 나오지 않으면 서비스를 개통할 수 없게 되며 실제로 성능 문제가 발생해서 개통한 서비스를 다시 취소하는 경우도 많이 있다.\r\n\r\n웹 애플리케이션 성능 테스트 툴은 웹 애플리케이션을 운영하기전 성능, 안정성 및 확장성을 평가하는 데 필수이며, 잘알려진 테스트 툴은 Java 오픈소스 `Apache JMeter`,  Node.js 오픈소스 `Artillery`, 네이버에서 Grinder를 이용해서 대규모 엔터프라이즈 환경용으로 만든 `nGrinder`, `Gatling`가 있습니다.\r\n\r\n이 외에도 JavaScript 오픈소스 Grafana 통합을 통한 시각화를 제공하는 `k6`,  Python 오픈소스 `Locust` 등 각각의 특징과 장점을 가지고 있어, 사용 목적과 환경에 따라 선택하여 사용되고 있습니다. \r\n\r\n> 최근 운영을 앞두고 있는 프로젝트의 웹 어플리케이션 성능 테스트를 진행하면서 웹 애플리케이션 성능 테스트 툴로 Java 오픈소스 `Apache JMeter`를 선택하였고 선택하게된 이유와 분석 내용을 포스팅 하겠습니다.\r\n\r\n## 부하 테스트\r\n간단히는 10분에서 1시간 정도 테스트해서 초당 평균 TPS와 하드웨어 및 네트워크 사용률을 분석한다. 추가적으로 1일에서 1주일 동안 지속적으로 부하르 발생시켜서 부하가 지속적으로 처리되는지도 확인한다. 장시간 부하 테스트 시 가용성 테스트를 병행한다.\r\n \r\n\r\n성능테스트를 수행할 경우 얻을 수 있는 이점은 다음과 같다.\r\n - 개발한 소프트웨어가 특정한 하드웨어에서 얼마나 많은 트랜잭션 혹은 사용자의 요청에 대응할 수 있는지 확인할 수 있다.\r\n - 성능 테스트를 통해 소프트웨어 혹은 하드웨어상에 존재하는 병목 구간과 문제 구간을 유추할 수 있다.\r\n - 개발한 서비스를 개통할때 얼마나 많은 사용자에게 서비스가 가능한지 사전에 예측하고 준비한다.\r\n - 성능 테스트 시 발생하는 각종 로그 데이터, 업무 데이터, 파일 등의 발생량을 고려하여 시스템의 스토리지, 디스크, 데이터베이스, 메모리 등의 사용량을 예측할 수 있고 향후 서비스 운영시 참조할 수 있는 기준값을 산출할 수 있다.\r\n - 테스트 활동을 통해 서비스를 개발하는 개발자, 기획자 및 관리자에게 항상 성능을 고려해서 기획, 설계, 개발해야 한다는 인식을 심어줄 수 있다.\r\n \r\n## 성능 테스트 전략 수립\r\n성능 테스트 전략 수립은 성능 테스트에 대한 목표를 정의하는 것부터 시작한다. 목표가 없는 테스트는 흐지부지 끝날 가능성이 많기 때문에 객과적인 기준에 따라 전략을 세우고 그 전략에 따라 지속적이고 반복적으로 성능 테스트를 하는 것 중요하다.\r\n \r\n### 1. 목표 수립\r\n성능 테스트 전략 수립 단계 중 가장 핵심은 바로 서비스할 소프트웨어에 대한 명확한 목표를 수립하는 것이다. 이 목표를 달성하기 위해 성능 테스트와 부하 테스트를 수행하고 튜닝작업을 진행한다. 만일 튜닝을 해도 목표를 달성하지 못한다면 하드웨어 증설이나 아키텍처 변경을 고려해 볼 필요가 있다.\r\n \r\n* `목적`\r\n  * 성능 테스트의 목적을 명확하게 기술한다 (새로 구축하는 소프트웨어가 목표로 하는 부하 상황에서 원활하게 작동하는지를 확인하거나 신규 도입하는 하드웨어가 개발된 소프트웨어를 기반으로 최대 어느정도까지 서비스가 가능한지 확인한다.)\r\n \r\n* `목표`\r\n  * 목적이 정의되었다면 목적에 기반한 목표를 정의한다. 목표는 매우 상세하게 기록하는 것이 좋은데 동시 사용자 수, 동시 사용자가 발생시키는 요청수 등의 예측치를 기술하는 것이 좋다. (화면 로그인의 최대 피크 타임을 오전 8시부터 9시 사이로 예상한다면 해당 시간 동안 초당 100번의 SSO 서비스가 가능해야 한다.)\r\n\r\n* `대상`\r\n  * 성능 테스트는 가능한 한 모든 서비스에 대해서 최대한 많이 하면 좋지만, 시간이 많이 들고 노력도 많이 필요한 작업이다. 때문에 성능 테스트의 목적과 목표를 검증할 수 있는 대표 서비스를 도출해서 수행하는 것이 좋다. 소프트웨어에서 제공하는 서비스 중 대표적으로 많이 사용하는 것과 반드시 검증해야 하는 서비스를 도출하되 전체 서비스의 20%를 넘지 않는 선에서 수행하는 것이 좋다 \r\n> 성능 테스트에서 황금률은 전체 20%의 서비스가 전체 자원의 80%를 소모한다는 법칙이 있는데 많은 서비스를 테스트한다고 해도 성능 검증에 큰 영향을 주지 않는 경우가 많다.\r\n\r\n \r\n목적/목표/대상을 수립했다면, 이에 대한 기준을 세워야 하는데 가장 좋은 기준은 이미 해당 서비스를 하고 있는 경우이다. 이 경우 현재 서비스의 상태와 총 사용자 수, 특정 시간대의 동시 사용자수, 그리고 초당 평균 요청 수 등을 뽑고 이 값을 기준으로 향후 어느 정도의 부하를 감당해야 하는지 정의하면 좋다.\r\n\r\n \r\n* `총 사용자수`\r\n  * 서비스를 사용하고 있느 혹은 사용할 예정인 전체 사용자 수를 정의한다. 사용자는 잠재적으로 서비스에 부하를 발생시키고 성능에 영향을 주는 주요한 항목이다. 현재 서비스의 가입자 항목, 가입은 하지 않았지만 '손님'과 같은 형태로 사용하는 경우도 모두 도출하는 것이 좋다.\r\n \r\n* `동시 사용자수`\r\n  * 총 사용자 수보다 더 중요한 항목이 바로 동시 사용자 수다. 동시 사용자 수에 대한 정의는 다소 애매한 부분이 있는데, 주로 특정 시간 동안 서비스를 요청하는 사용자 수를 의미한다. 대부분 특정 시간대(피크 타임)의 1초 동안 서비스를 요청하는 사용자 수로 정의하며 정확한 집계가 어렵다면 웹서버나 WAS의 ACCESS 로그에 찍히는 IP 정보와 시간을 분석해서 도출한다.\r\n \r\n* `평균 TPS`\r\n  * TPS는 초당 요청 횟수를 의미하며 성능 테스트시 가장 보편적으로 사용하는 수치이다. 이 역시 동시 사용자수와 마찬가지로 피크 타임 때의 로그를 분석해서 평균 TPS를 수집하는데, 이때 주의할 것은 단순한 HTML이나 이미지 파일 등 미들웨어나 데이터 베이스에 큰 영향을 주지 않는 요청은 제외시키는 것이 좋다.\r\n \r\n현행 성능 기준 정보를 바탕으로 목표에 대한 값과 대상을 산출하게 되며 향후 5년간 서비스의 발전을 고려해서 최종 성능 테스트 도달 목표를 정의하는 것이 좋다. 예를 들어 현재 동시 사용자가 100명이고 평균 TPS가 2000인데 해당 비즈니스가 매년 20%씩 증가한다고 가정한다면 이를 기준으로 5년 후의 동시 사용자와 평균 TPS를 산정하는 것이다.\r\n \r\n위 설명들은 이미 서비스가 제공되고 있어서 서비스 업그레드나 하드웨어 업그레이드, 혹은 개편 시에 기존 서비스를 기반으로 성능 테스트 기준 정보를 산출하는 것이다. 그런데 신규로 만들고 있는 서비스라면 이를 도출하기가 매우 어렵다. 이러한 경우는 목표를 잡을때 다소 추상적으로 잡을 수 밖에 없고 테스트할 대상도 좀 더 많이 정의해야 한다.\r\n \r\n### 2. 구간별/대상별 목표 수립\r\n앞서 설정한 목표는 성능 테스트에 사용할 상위 수준의 목표이며 해당 항목들이 정의되면 이제 상세 목표를 수립해야 한다. 상세 목표를 수립할 때는 구간별 목표와 대상별 목표를 정의해야 한다. 일반적인 웹기반 프로젝트에서는 미들웨어에서의 성능 수치, 데이터베이스의 성능 수치, 대내/대외 연계를 위한 성능 수치, 최종적으로 네트워크의 성능 수치를 고려해야 한다. 이러한 구간별 목표는 클라이언트의 요청부터 응답까지 수행되는 각 구간을 사전에 정의하고 구간에 따른 누적 수치를 산출하게 되는데 중요한 것은 구간별로 수치값을 측정할 수 있는 환경이 마련되어 있어야 한다는 점이다.\r\n \r\nJMeter에서의 성능 테스트는 클라이언트의 요청과 응답을 기준으로 측정하기 때문에, 구간별 측정 방법이 제공되지 않으면 어떤 서비스의 어떤 구간에서 문제가 발생했는지 알 수가 없다.\r\n \r\n구간별 목표가 정의되었다면 성능 테스트 대상 서비스별 목표 수립이 필요하다. 동일한 소프트웨어에서 제공하는 서비스라도 서비스의 성격에 따라 목표가 달라지기 때문이다.\r\n \r\n* 로그인 업무\r\n  * 주로 업무가 시작되는 시간에 집중적으로 부하가 발생한다. 아침 출근 한시간 전부터 출근 후 한 시간이 가장 피크타임이다. 그리고 점심시간 이후 오후 근무 시작 시점붙터 한시간 역시 로그인이 가장 많은 부하를 받는다.\r\n \r\n* 공통 업무\r\n  * 업무마다 공통적으로 호출되는 기능의 경우 응답 시간은 매우 빠르지만 워낙 호출되는 트랜잭션 수가 많기 때문에 최대한의 성능 튜닝 및 사전 검증이 필요하다.\r\n \r\n* 통계 업무\r\n  * 통계 화면은 주로 오전 시간대에 많은 부하가 발생한다. 전날 혹은 전월 통계를 기반으로 금일 작업 계획을 세우기 때문이다. 상대적으로 오후에는 부하가 급격히 떨어진다.\r\n \r\n최근에는 글로벌 기업이 늘고 글로벌 서비스가 많아지면서 부하가 발생하는 특정 시간대를 규정하기가 어려운 경우도 많다. 그러므로 목표로 하는 서비스 상황을 고려해서 성능을 테스트할 서비스를 도출하고 각각에 대한 목표 수치를 수립할 필요가 있다. \r\n \r\n\r\n## 참고\r\n\r\n- https://www.redline13.com/blog/2019/05/jmeter-thread-count/\r\n- https://12bme.tistory.com/503"},{"excerpt":"저장 방식 단점 보완을 위한 Persist Option 문제점 보완을 위한 Persist Option\n 메모리 기반이지만 Redis는 영속적인 데이터 보존(Persistence)이 가능하다. (메모리는 원래 휘발성) 기존 데이터를 영속화하여 복구, 유지시키기 위해서는 디스크에 데이터 백업해주는 과정이 필요하다.  백업 방식에는 1) RDB snapshot…","fields":{"slug":"/persistence/"},"frontmatter":{"date":"May 22, 2024","title":"Persist Option 데이터 영구 저장하기 AOF, RDB","tags":["DataBase","Redis"]},"rawMarkdownBody":"\r\n## 저장 방식 단점 보완을 위한 Persist Option \r\n![문제점 보완을 위한 Persist Option](./3.PNG)\r\n 메모리 기반이지만 Redis는 영속적인 데이터 보존(Persistence)이 가능하다. (메모리는 원래 휘발성) 기존 데이터를 영속화하여 복구, 유지시키기 위해서는 디스크에 데이터 백업해주는 과정이 필요하다. \r\n\r\n백업 방식에는 1) RDB snapshot, 2) AOF 2가지가 있다.\r\n> 여기서 `RDB`는 Redis DataBase를 의미한다.\r\n\r\n\r\n### RDB snapshot 방식\r\n![RDB snapshot 방식](./4.PNG)\r\n\r\n특정 시점을 스냅샷으로 남겨 데이터를 저장하는 방식을 말한다. redis.conf 파일에서 스냅샷 저장에 대한 주기 설정을 할 수 있다.\r\n\r\n### RDB snapshot 설정\r\n아래는 메신저 프로젝트 테스트 서버의 redis.conf에 `save 900 1 300 10 60 10000` 설정 값이다. 주석된 내용 처럼 조건이 여러 개 있을 때는 조건 중 하나라도 만족하면 save시킨다. 즉, 900초 동안 1개 이상의 데이터가 변경되거나 300초 동안 10개 이상의 데이터가 변경되거나 60초 동안 10000개 이상의 데이터가 변경되면 dump.rdb 파일을 생성하며 디스크에 데이터를 백업한다. 리부팅시에는 dump.rdb 파일이 있으면 읽어서 복구시킨다.\r\n![redis.conf 설정](./2.PNG)\r\n\r\n> RDB(snapthot)는 설정한 주기 및 데이터 양에따라 메모리에 있는 내용을 스냅샷을 떠서 DISK에 옮겨 담는 방식이다.\r\n\r\nredis-cli에서 RDB 파일을 생성을 BGSAVE 또는 SAVE 명령으로도 할 수 있다.\r\n\r\nBGSAVE와 SAVE 의 차이점은 어떤 프로세스가 파일 쓰기 작업을 처리하는지에 따라 다릅니다.\r\n\r\nSAVE는 main process가 직접 파일 쓰기 작업을 처리하므로 작업이 끝날 때까지 클라이언트의 명령을 처리할 수 없고,\r\n\r\nBGSAVE는 child process가 생성되어 background로 실행되므로 쓰기 작업 중에도 클라이언트의 명령을 정상적으로 처리할 수 있다.\r\n \r\n#### BGSAVE 동작 순서\r\n \r\n+ Child process를 fork() 한다.\r\n+ Child process는 데이터를 새 RDB temp 파일에 쓴다.\r\n+ 쓰기가 끝나면 기존 파일을 지우고, 이름을 변경한다.\r\n\r\n#### SAVE 동작순서 \r\n+ Main process가 데이터를 새 RDB temp 파일에 쓴다.\r\n+ 쓰기가 끝나면 기존 파일을 지우고, 새 파일로 교체한다.\r\n\r\n> BGSAVE 방식은 fork를 하기 때문에 메모리를 거의 두배 가량 사용하므로 이에 주의 해야 한다.\r\n\r\n\r\n \r\n#### [stop-writes-on-bgsave-error]\r\n```\r\nstop-writes-on-bgsave-error yes\r\n```\r\n이 값이 yes이면, RDB 파일을 디스크에 저장하다 실패했을 때, 레디스는 모든 쓰기 요청을 거부합니다.\r\n\r\n디스크 쓰기에 실패하는 경우는 여유 공간이 부족하거나, 권한 부족, 디스크 물리적 오류 등이 있을 수 있고, 빠른 조치를 취해야 다시 쓰기 작업을 진행할 수 있다.\r\n\r\n서비스를 계속하는 것이 중요하고 모니터링이 잘 되어 있다면 no로 설정하는 것이 좋다.\r\n\r\n\r\n\r\n\r\n\r\n또한, 이 설정은 SAVE 이벤트만 해당하며, 직접 BGSAVE을 입력한 경우에는 디스크 저장에 실패하더라도 쓰기가 정상적으로 처리됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n3.rdbcompression\r\n\r\n\r\n\r\n\r\nrdbcompression yes\r\n\r\n\r\n\r\n\r\nRDB 파일을 쓸 때 압축 여부를 정합니다. (압축 알고리즘은 LZF를 사용하며 압축률이 그다지 높지 않습니다.)\r\n\r\n\r\n\r\n4.rdbchecksum\r\n```\r\nrdbchecksum yes\r\n```\r\n\r\nRDB 파일 끝에 CRC64 checksum 값을 기록할지 정합니다.\r\n\r\n\r\n5. dbfilename\r\n```\r\ndbfilename dump.rdb\r\n```\r\n\r\nRDB 파일명을 지정하며, path는 working directory에 따릅니다.\r\n\r\n\r\n6. dir\r\n```\r\ndir /var/lib/redis\r\n```\r\nworking directory 경로를 정합니다.\r\n\r\n#### AOF 방식\r\n\r\n\r\n## 선택 기준\r\n백업은 필요하지만 어느정도 손실이 괜찮은 경우 ➡️ RDB 사용<Br>\r\n장애 상황 직전까지의 데이터 보장이 필요한 경우 ➡️ AOF 사용\r\n\r\n## 다음\r\n\r\n[Redis의 저장 방식](../oauth-2.0/index.md) Redis의 저장 방식"},{"excerpt":"서론 이번 글에서는 OAuth2.0에 대해서 알아보고 이것을 어떻게 적용하여 서버를 구성하는지 살펴 보겠습니다.\n실제로 실무에서 인증서버 OAuth2.0 적용하여 구성하였고 구성하는동안 공부 및 정리한 내용을 다루겠습니다. OAuth 2.0란? OAuth2.0 사용 예시 OAuth 서버는 인증서버로부터 인증된 클라이언트만 접근 하도록 할 수 있으며, 추가…","fields":{"slug":"/oauth-2.0/"},"frontmatter":{"date":"May 16, 2024","title":"OAuth 2.0 개념(Open Authorization)?","tags":["인증","OAuth 2.0"]},"rawMarkdownBody":"\r\n## 서론\r\n\r\n이번 글에서는 OAuth2.0에 대해서 알아보고 이것을 어떻게 적용하여 서버를 구성하는지 살펴 보겠습니다.\r\n실제로 실무에서 인증서버 OAuth2.0 적용하여 구성하였고 구성하는동안 공부 및 정리한 내용을 다루겠습니다.\r\n\r\n\r\n## OAuth 2.0란?\r\n![OAuth2.0 사용 예시](./1.PNG)\r\n\r\nOAuth 서버는 인증서버로부터 인증된 클라이언트만 접근 하도록 할 수 있으며, 추가로 클라이언트 별로 권한을 부여 하여 권한 별로 처리 할 수 있도록 할 수 있다. \r\n\r\n다양한 서비스(웹서비스, 모바일앱, IOT기기등등) 이런 다양한 환경에서도 당연하게 로그인, 사용자 인증과 같은 절차는 필수적으로 이루어진다. 이렇게 다양한 환경을 모두 아우를 수 있도록 사용자 인증 절차를 표준화한 것이 OAuth이다.\r\n> 접근 권한을 위임(Delegated Authorization)받을 수 있는 표준 프로토콜\r\n\r\n예를 들어 페이스북, 카카오톡 개발자 센터에 가보면 로그인 기능의 경우 OAuth 2.0 형태로 되어있으며, 내 앱에 페이스북, 카카오톡 로그인을 붙여 사용자 정보를 가져와서 SNS 로그인 기능을 구현할 수 있으며, 로그인 한 사용자의 페이스북, 카카오톡을 컨트롤 할 수 있다.\r\n\r\n> OAuth 2.0은 1.0에서 알려진 보안 문제 등을 개선한 버젼이다.\r\n   \r\n그리고 OAuth2는 이름에서도 알 수 있듯이 OAuth의 2번째 버전이고, 현재는 OAuth2가 RFC 표준으로 등록되어서 사용되고 있다.\r\nOAuth2는 기본적으로 아래의 흐름을 갖고 있다.\r\n\r\n## OAuth 2.0 용어 정리\r\n\r\n|구분|설명|\r\n|-|---|\r\n|**Resource Server**| Client의 액세스 토큰을 검증하여 요청을 처리한다.<br/>(ex - Google, Naver, Kakao ...) <br/><br/>클라이언트(Client) - 이 서버로 인증 서버에서 발급받은 Token을 넘겨 검증을 한다.|\r\n|**Authorization Server**| Client를 인증하고, Client에게 액세스 토큰을 발급또는 권한 부여를 담당한다.|\r\n|**Access Token**|API 통신에 대한 접근 권한을 Resource Owner가인가하였음을 나타내는 자격증명이다.|\r\n|**Refresh Token**|access token은 보안상 만료기간이 짧기 때문에 얼마 지나지 않아 만료되면 사용자는 로그인을 다시 시도해야한다. 그러나 refresh token이 있다면 access token이 만료될 때 refresh token을 통해 access token을 재발급 받아 재 로그인 할 필요없게끔 한다.|\r\n|**Grant Type**|**허가를 받는 유형**애플리케이션이 사용자 데이터를 안전하게 액세스하도록 돕는 방식. 주요 유형으로는 웹 애플리케이션에 적합한 **Authorization Code Grant (권한 부여 코드 유형)**, Client 사이드 애플리케이션에 적합한 **Implicit Grant (암시적 유형)**, 신뢰할 수 있는 애플리케이션에서 사용하는 **Password Grant**, 서버 간 통신을 위한 **Client Credentials Grant (Client 자격 증명 유형)**, 만료된 토큰 갱신을 위한 **Refresh Token Grant (갱신 토큰 유형)** 이 있다.|\r\n| **Scope**| 클라이언트가 요청하는 권한의 범위를 정의하여, 액세스 토큰이 어떤 자원과 작업에 접근할 수 있는지 명시한다. 구글로 로그인을 했다면, 그 서비스 안에서 사용할 수 있는 모든 기능 |\r\n|**Authorized redirect URIs**| 예를 들어, 사용자가 \"특정 사이트\"에 로그인하려고 할 때, 구글 로그인을 선택하면 구글 로그인 페이지로 이동하고 로그인이 끝나면, 구글은 사용자를 다시 \"특정 사이트\"로 돌려보냅니다. 이때 사용자를 돌려보낼 주소이다.\r\n|**Client ID**| Client를 식별하는 식별자 ID를 의미 한다.\r\n|**Client Secret**| Client ID에 해당한 PASSWORD 이다.\r\n\r\n\r\n\r\n##  OAuth 2.0 인증 과정\r\n\r\n아래 이미지는 주로 소셜 로그인에 사용되고 있는 `Authorization Code Grant (권한 부여 코드 유형)`을 적용시킨 `OAuth 2.0 인증 과정 프로세스 예시`입니다.\r\n\r\n![OAuth 2.0 Authorization Code Grant](./3.PNG)\r\n\r\n* **서비스(사용자가 이용하려는 서비스) - Client**\r\n* **인증 서버 - Authorization Server**\r\n\r\n크게 요약해보면,\r\n\r\nClient(사용자가 이용하려는 서비스)에서 서비스를 이용하려는 사용자를 대신하여 Authorization Server와 Resource Server에 요청을 보내 필요한 정보를 서로 비교해 유효성을 판단한다.\r\n\r\n##  인증 과정 자세히 \r\n### 1. 사용자는 서비스를 이용하기 위해 로그인 화면에 접근 한다.\r\n### 2. 그럼 서비스는 사용자에게 로그인 페이지를 제공하게된다. 로그인 페이지에서 사용자는 \"소셜 로그인\"을 시도한다.\r\n\r\n![소셜 로그인](./4.PNG)\r\n![1 ~ 2. 로그인 요청](./5.PNG)\r\n\r\nClient 서버는 OAuth 프로세스를 시작하기 위해 사용자의 브라우저를 Authorization Server로 보내야한다.\r\n\r\nClient 서버는 이때 Authorization Server가 제공하는 Authorization URL에 `response_type` , `client_id` , `redirect_uri` , `scope` 등의 매개변수를 포함하여 보낸다.\r\n\r\n```\r\nhttps://accounts.google.com/o/oauth2/auth?\r\n&response_type=code\r\n&client_id=1234567890-abcde\r\n&redirect_uri=https://yourapp.com/callback\r\n&scope=email,profile\r\n```\r\n### 3. Authorization URL로 이동된 사용자는 제공된 로그인 페이지에\r\n### 4. ID/PW 입력하여 인증 시도 \r\n### 5. Authorization Code 발급하고,\r\n### 6. Redirect URI로 Redirect\r\n```\r\nhttps://yourapp.com/callback?code=AUTHORIZATION_CODE\r\n```\r\n\r\n인증이 성공되었다면, Authorization Server는 제공된 Redirect URI로 사용자를 리다이렉션시킬 것 이다. 이때, Redirect URI에 Authorization Code를 포함하여 사용자를 리디렉션 시킨다.\r\n\r\n이때, Authorization Code란 Client가 Access Token을 획득하기 위해 사용하는 임시 코드이며 Authorization Code Grant 타입 인증방식의 주요 포인트다.\r\n\r\n### 7. Client 서버는 Authorization Server에 Authorization Code를 전달하고, Access Token을 응답 \r\n\r\nClient는 발급받은 사용자가 쿠키나 세션에 Access Token을 저장하고, 이후 Resource Server에서 사용자가 리소스서버에 접근하기 위해 Access Token을 같이 전달하게 된다.\r\n\r\n당연히 `Access Token`은 유출되어서는 안되고 제 3자가 가로채지 못하도록 HTTPS 연결을 통해서만 사용될 수 있다. 아래는 ASP.NET Core 애플리케이션에서 OpenID Connect와 OAuth 2.0 인증 및 인가를 구현하기 위한 라이브러리 프레임워크 `Openiddict`로 적용한 프로젝트에 `HTTP`로 통신했을때 나왔던 에러다.\r\n```\r\n{\r\n  \"error\": \"invalid_request\",\r\n  \"error_description\": \"This server only accepts HTTPS requests.\",\r\n  \"error_uri\": \"https://documentation.openiddict.com/errors/ID2083\"\r\n}\r\n```\r\n\r\n토큰 발급 성공 예시\r\n![토큰](./8.PNG)\r\n\r\nAuthorization Code와 Access Token 교환은 `token` 엔드포인트에서 이루어진다. 아래는 token 엔드포인트에서 Access Token을 발급받기 위한 HTTP 요청의 예시이다. 이 요청은 `application/x-www-form-urlencoded` 의 형식에 맞춰 필수 매개변수를 전달해야한다.\r\n\r\n```\r\nPOST https://oauth2.googleapis.com/token\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\nclient_id=YOUR_CLIENT_ID&\r\nclient_secret=YOUR_CLIENT_SECRET&\r\ncode=AUTHORIZATION_CODE&\r\nredirect_uri=YOUR_REDIRECT_URI&\r\ngrant_type=authorization_code\r\n```\r\n\r\n- `grant_type` : Authorization Code Grant에 맞는 `authorization_code` 로 설정 \r\n- `code` : 발급받은 Authorization Code\r\n- `redirect_uri` : Redirect URI\r\n- `client_id` : Client ID\r\n- `client_secret` : Client ID에 해당하는 Client Secret이 발급된 경우 포함하여 요청해야한다.\r\n\r\n![3 ~ 7. 로그인 요청](./6.PNG)\r\n\r\n\r\n### 8 ~ 9. 인증 완료 및 로그인 성공\r\n\r\n위 과정을 성공적으로 마치면 Client 서버는 사용자에게 로그인이 성공하였음을 알린다.\r\n\r\n\r\n\r\n### 10 ~ 13. Access Token으로 리소스 접근\r\n\r\n이후 사용자가 Resource Server의 리소스가 필요한 기능을 Client 서버에 요청한다. Client 서버는 위 과정에서 발급받고 저장해둔 사용자의 Access Token을 사용하여 리소스 서버에 토큰을 검증하고, 사용자가 Clien 서버에 요청한 정보를 제공한다.\r\n\r\n![10 ~ 13 로그인 요청](./7.PNG)\r\n\r\n\r\n\r\n\r\n아래 이미지는 **Client Credentials Grant Type**을 적용시킨 OAuth 2.0 인증과정 프로세스 예시입니다.\r\n\r\n\r\n![OAuth 2.0 Client Credentials Grant Type](./2.PNG)\r\n\r\n프로젝트에선 Authorization Code Grant 형식을 적용하진 않았지만 인증서버 구축 전 일반적 사용되는 소셜 로그인을 분석하고 공부한 내용을 정리하겠습니다."},{"excerpt":"서론 최근 회사내 인증 서버를 구축하여 프로젝트 진행 과정동안 공부한 내용을 정리했습니다. 이 프로젝트의 주요 목표는 OAuth 2.0, OpenID Connect를 활용하여 API서버간 안전하고 확장 가능한 인증 시스템을 만드는 것입니다. 이 글에서는 OAuth 2.0과 OpenID Connect의 개념, 그리고 OpenIddict 적용 방법에 대해 공…","fields":{"slug":"/intro/"},"frontmatter":{"date":"May 16, 2024","title":"[정리] 인증서버 구축","tags":["인증/인가","프로젝트"]},"rawMarkdownBody":"\r\n## 서론\r\n\r\n최근 회사내 인증 서버를 구축하여 프로젝트 진행 과정동안 공부한 내용을 정리했습니다. 이 프로젝트의 주요 목표는 OAuth 2.0, OpenID Connect를 활용하여 API서버간 안전하고 확장 가능한 인증 시스템을 만드는 것입니다. 이 글에서는 OAuth 2.0과 OpenID Connect의 개념, 그리고 OpenIddict 적용 방법에 대해 공부하고 정리한 내용을 포스팅하겠습니다.\r\n\r\n\r\n## 인증 방식 프로세스\r\n\r\n- 사전에 개별 제공된 인증 정보로서 인증 서버를 통해 인증을 거쳐야 한다.\r\n- 인증 성공 시 인증 서버로 부터 발급 받은 Access Token을 API 서버 연동 호출 시에 HTTP 헤더에 포함시킨다.\r\n- API 서버는 외부 API 서버로 전달 받은 토큰 정보를 이용하여 토큰의 적합성 검사를 진행 한 후 토큰이 정상일 경우 API를 호출하여 그 Response를 외부 API 서버에 반환 한다.\r\n\r\n![외부서버 연동 인증 프로세스](./1.PNG)\r\n\r\n## 인증서버 구축의 주요 목표\r\n\r\n- 보안 강화\r\n- 규제 준수\r\n- 확장성과 유연성\r\n- 중앙 집중식 사용자(외부서버) 관리\r\n\r\n\r\n## 다음\r\n\r\n[OAuth 2.0에 대하여](../oauth-2.0/index.md) OAuth 2.0과 OpenID Connect의 개념정리"},{"excerpt":"How to change the favicon? The favicon is located in . If you replace that image, the favicon will change. If you want to change the name of the favicon, change the  property of  in . Utterance is no…","fields":{"slug":"/other-tips/"},"frontmatter":{"date":"May 04, 2021","title":"🤩 4. Other Tips","tags":["hoodie","other-tips"]},"rawMarkdownBody":"\r\n## How to change the favicon?\r\n\r\nThe favicon is located in `static/favicon.png`. If you replace that image, the favicon will change.\r\n\r\nIf you want to change the name of the favicon, change the `icon` property of `gatsby-plugin-manifest` in `gatsby-config.js`.\r\n\r\n## Utterance is not working properly.\r\n\r\nIn the http environment, utterance may not work properly. Host your blog with https.\r\n\r\n## How to set OG Image?\r\n\r\nReplace the `og-image.png` file in the `/static` directory with your own image file.\r\n\r\n## Do you have another question?\r\n\r\nPlease comment on this article or [open an issue](https://github.com/devHudi/gatsby-starter-hoodie/issues) in the gatsby-starter-hoodie repository. Your participation advances gatsby-starter-hoodie. Thank you 😎.\r\n"},{"excerpt":"1. Add a post You can add posts by creating a new markdown document in the  path. 1-1. Post file structure There are two ways to add a new document. The first is to create a markdown file for a singl…","fields":{"slug":"/writing-guide/"},"frontmatter":{"date":"May 03, 2021","title":"🤔 3. Writing Guide","tags":["hoodie","writing-guide"]},"rawMarkdownBody":"\r\n## 1. Add a post \r\n\r\nYou can add posts by creating a new markdown document in the `contents/post` path.\r\n\r\n### 1-1. Post file structure\r\n\r\nThere are two ways to add a new document. The first is to create a markdown file for a single document without a directory. If you are writing about JavaScript, you can create a `about-javascript.md` file in the `contents/posts` directory.\r\n\r\nThe second is to create a directory and create an `index.md` file in it. This method is useful when the document contains several additional files such as picture files.\r\n\r\nEach file name or directory name becomes a unique address of the document and can be accessed as follows. `https://siteURL/about-javascript`.\r\n\r\n### 1-2. Frontmatter\r\n\r\nThe Markdown document you create contains the document's metadata called frontmatter.\r\n\r\n```\r\n---\r\ntitle: \"🤔 3. Writing Guide\"\r\ndescription: \"How to write and add a post?\"\r\ndate: 2021-05-03\r\nupdate: 2021-05-03\r\ntags:\r\n  - hoodie\r\n  - writing-guide\r\nseries: \"Getting started your blog with gatsby-starter-hoodie\"\r\n---\r\n```\r\n\r\nAbove is the frontmatter of the document you are currently reading. Among them, title and date are required. It is recommended to enclose the string with spaces in quotation marks.\r\n\r\n### 1-3. Writing markdown\r\n\r\nIf you have written a Frontmatter, you can write your markdown document under it. gatsby-starter-hoodie supports most Markdown syntax. To learn more about Markdown syntax, see the [Mastering Markdown](https://guides.github.com/features/mastering-markdown/) documentation on GitHub.\r\n\r\n## 2. Syntax Highlighting & Katex\r\n\r\n### 2-1. Syntax Highlighting\r\n\r\nSyntax highlighting based on Prism.JS is supported.\r\n\r\n#### Examples\r\n\r\nJavascript\r\n\r\n```javascript\r\nconsole.log(\"Hello, world!\")\r\n```\r\n\r\nPython\r\n\r\n```python\r\nprint(\"Hello, world!\")\r\n```\r\n\r\nIt supports a wider variety of other languages. Check it out on the [Prism.js website](https://prismjs.com/).\r\n\r\n### 2-2. Katex\r\n\r\nIt supports Katex syntax, you can easily express complex formulas.\r\n\r\n#### Inline mode\r\n\r\n$$E = m c^{2}$$\r\n\r\n#### Block mode\r\n\r\n$$\r\n\\int_{0}^{\\infty} f(x) dx\r\n$$\r\n\r\n## 3. Add images to a post\r\n\r\nYou can easily embed images using relative paths. It is easy to manage documents containing images by creating a directory.\r\n\r\n![Sample Image Caption](sample-image.jpg)\r\n\r\nImages are loaded with Lazy Loading, so you can secure fast document loading speed.\r\n\r\n> ⚠ The extension of the file must be set to lowercase.\r\n\r\n## 4. Tagging\r\n\r\n![](tag-example.jpg)\r\n\r\nYou can classify and search documents by tag set in Frontmatter. All tags you set can be viewed and searched in `https://siteUrl/tags`.\r\n\r\n## 5. Series\r\n\r\n![](series-example.jpg)\r\n\r\nYou can publish multiple related documents in a series. The series set in Frontmatter is grouped together and shown at the top of the document. This can be useful for serialized documents with an order. Series documents are displayed in ascending order of creation date.\r\n\r\nThe current document is also set in a series called `Getting started your blog with gatsby-starter-hoodie`.\r\n"},{"excerpt":"Getting started your blog with gatsby-starter-hoodie by following steps below. It's very easy 😉. 1. Create a Gatsby site Make sure you have node.js and gatsby-cli installed on your computer. 2. Start…","fields":{"slug":"/quick-start/"},"frontmatter":{"date":"May 02, 2021","title":"🚀 2. Quick Start","tags":["hoodie","quick-start"]},"rawMarkdownBody":"\r\nGetting started your blog with gatsby-starter-hoodie by following steps below. It's very easy 😉.\r\n\r\n## 1. Create a Gatsby site\r\n\r\n> Make sure you have **node.js** and **gatsby-cli** installed on your computer.\r\n\r\n```\r\n$ npx gatsby new my-hoodie-blog https://github.com/devHudi/gatsby-starter-hoodie\r\n```\r\n\r\n## 2. Start dev server\r\n\r\n```\r\n$ cd my-hoodie-blog\r\n$ npm run start\r\n```\r\n\r\nNow you can access to your blog at localhost:8000.\r\n\r\n## 3. Create your own Github repository\r\n\r\nUtterance comment widget is based on **Github issue system**. So you need your own GitHub repository. Also, if you want to publish your blog through Github Pages or Netlify, the Github Repository is a necessary.\r\n\r\nIf you don't know how to create a GitHub repository, follow the [official GitHub documentation](https://docs.github.com/en/github/getting-started-with-github/create-a-repo).\r\n\r\n### Add remote repository\r\n\r\n```\r\n$ git init\r\n$ git remote add origin https://github.com/{YOUR_GITHUB_NAME}/{YOUR_REPOSITORY_NAME}\r\n```\r\n\r\n## 4. Write blog-config.js\r\n\r\n```javascript\r\nmodule.exports = {\r\n  title: \"MY BLOG\",\r\n  description: \"Hello, This is my blog\",\r\n  author: \"YOUR NAME\",\r\n  siteUrl: \"https://myblog.com\",\r\n  links: {\r\n    github: \"https://github.com\",\r\n    facebook: \"https://www.facebook.com\",\r\n    instagram: \"https://www.instagram.com\",\r\n    etc: \"https://www.google.com/\",\r\n  },\r\n  utterances: {\r\n    repo: \"{YOUR_GITHUB_NAME}/{YOUR_REPOSITORY_NAME}\",\r\n    type: \"pathname\",\r\n  },\r\n}\r\n```\r\n\r\ngatsby-starter-hoodie provides a configuration file called `blog-config.js`. In this file, you can configure blog, biography (profile), and utterance. The website settings you are currently viewing are as above.\r\n\r\nConfigure `blog-config.js` to suit your blog. However, it is recommended not to modify `utterances.type`.\r\n\r\n### Change profile image\r\n\r\nReplace `static/profile.png` with the image you want. To change the image file name, you need to change the source code of `src/components/Bio.jsx`.\r\n\r\n## 5. Add your content\r\n\r\nMarkdown content is in `contents/posts`. You can write and add your articles like the sample posts here. [Click here](/writing-guide) to see the detail writing guide.\r\n\r\n## 6. Deploy your blog\r\n\r\n### 6-1 via Netlify\r\n\r\nFollow the Connecting to Netlify steps in [A Step-by-Step Guide: Gatsby on Netlify](https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/). It's not difficult.\r\n\r\nIf you connect the github repository using Netlify, it is automatically distributed whenever you push it, so it is convenient.\r\n\r\n### 6-2. via Github Pages\r\n\r\n#### Case 1\r\n\r\nIf the repository name is in the form of `{YOUR_GITHUB_NAME} .github.io`, run it below.\r\n\r\n```\r\n$ npm run deploy-gh\r\n```\r\n\r\n#### Case 2\r\n\r\nIf the repository name is not in the form of `{YOUR_GITHUB_NAME} .github.io`, run it below.\r\n\r\n```\r\n$ npm run deploy-gh-prefix-paths\r\n```\r\n\r\nIn the above case, you need to change `pathPrefix` in `gatsby-config.js` to your repository name.\r\n\r\n### 6-3. other platforms\r\n\r\n```\r\n$ npm run build\r\n```\r\n\r\nYou can build the gatsby website with the command above. The build output is created in the `/public` directory. Deploy the `/public` directory using the command for the platform you want to deploy.\r\n\r\n## 7. Cutomize\r\n\r\n### Project Structure\r\n\r\nYou can customize your own gatsby-starter-hoodie by referring to the following file structure 🙊.\r\n\r\n```\r\n├── node_modules\r\n├── contents\r\n│   └── posts // your articles are here\r\n├── public // build outputs are here\r\n└── src\r\n    ├── assets\r\n    │   └── theme // theme config is here\r\n    ├── components\r\n    │   └── Article\r\n    │       └── Body\r\n    │           └── StyledMarkdown\r\n    │               └── index.jsx // markdown styles are here\r\n    │   ...\r\n    ├── fonts // webfonts are here\r\n    ├── hooks\r\n    ├── images\r\n    ├── pages // page components are here\r\n    ├── reducers\r\n    ├── templates // post components are here\r\n    └── utils\r\n```\r\n"},{"excerpt":"About gatsby-starter-hoodie gatsby-starter-hoodie is a gatsby theme created for writing tech blogs. Markdown, Code Highlighting in various programming languages, and Katex syntax are supported. Also,…","fields":{"slug":"/about-hoodie/"},"frontmatter":{"date":"May 01, 2021","title":"🎇 1. About gatsby-starter-hoodie-test","tags":["hoodie","about"]},"rawMarkdownBody":"\r\n## About gatsby-starter-hoodie\r\n\r\ngatsby-starter-hoodie is a gatsby theme created for writing tech blogs. Markdown, Code Highlighting in various programming languages, and Katex syntax are supported. Also, you can easily categorize articles into tags and series.\r\n\r\nStart your blog with a neatly designed gatsby-starter-hoodie that supports dark mode.\r\n\r\n## Features\r\n\r\n- Markdown\r\n- Code Highlighting\r\n- Katex Syntax\r\n- Dark Mode (Responsive to the settings of the OS)\r\n- Tag Categoriazation\r\n- Series Categorization\r\n- Responsive Web\r\n- SEO\r\n- Utterance (Comment widget)\r\n\r\n## Let's get started\r\n\r\nFollow the [Quick Start](/quick-start)\r\n"},{"excerpt":"파비콘은 어떻게 변경하나요?  에 파비콘 파일이 위치해 있습니다. 이미지 파일을 대체하면 파비콘을 변경할 수 있습니다. 만약 파비콘 파일의 이름을 변경하고 싶다면,  파일의  에서  속성을 변경하셔야합니다. Utterance 가 제대로 작동하지 않아요. http 환경에서는 Utterance 가 제대로 작동하지 않을 수 있습니다. 여러분의 웹사이트를 htt…","fields":{"slug":"/other-tips-kr/"},"frontmatter":{"date":"April 04, 2021","title":"🤩 4. 그 외 팁들","tags":["hoodie","other-tips"]},"rawMarkdownBody":"\r\n## 파비콘은 어떻게 변경하나요?\r\n\r\n`static/favicon.png` 에 파비콘 파일이 위치해 있습니다. 이미지 파일을 대체하면 파비콘을 변경할 수 있습니다.\r\n\r\n만약 파비콘 파일의 이름을 변경하고 싶다면, `gatsby-config.js` 파일의 `gatsby-plugin-manifest` 에서 `icon` 속성을 변경하셔야합니다.\r\n\r\n## Utterance 가 제대로 작동하지 않아요.\r\n\r\nhttp 환경에서는 Utterance 가 제대로 작동하지 않을 수 있습니다. 여러분의 웹사이트를 https 환경으로 제공하세요.\r\n\r\n## OG Image 를 설정하고 싶어요.\r\n\r\n`/static` 디렉토리의 `og-image.png` 파일을 여러분이 원하는 이미지 파일로 대체하세요.\r\n\r\n## 다른 질문이 있으신가요?\r\n\r\n이 문서에 댓글을 달거나 gatsby-starter-hoodie 레포지토리에 [이슈를 열어주세요](https://github.com/devHudi/gatsby-starter-hoodie/issues). 여러분의 참여가 gatsby-starter-hoodie 를 더욱 발전시킵니다. 감사해요 😎.\r\n"},{"excerpt":"1. 포스트 추가하기  경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다. 1-1. 포스트 파일 구조 새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면,  파일을  디렉토리에 추가할 수 있습니다. 두번째 방법은 먼저 디…","fields":{"slug":"/writing-guide-kr/"},"frontmatter":{"date":"April 03, 2021","title":"🤔 3. 작성 가이드","tags":["hoodie","writing-guide"]},"rawMarkdownBody":"\r\n## 1. 포스트 추가하기\r\n\r\n`contents/post` 경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다.\r\n\r\n### 1-1. 포스트 파일 구조\r\n\r\n새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면, `about-javascript.md` 파일을 `contents/posts` 디렉토리에 추가할 수 있습니다.\r\n\r\n두번째 방법은 먼저 디렉토리를 생성한 뒤, 디렉토리 안에 `index.md` 파일을 추가하는 것 입니다. 이 방법은 문서 내에 여러 이미지 파일 등 부수적인 파일 여러개가 포함되었을 때 유용합니다.\r\n\r\n첫번째 방법으로 생성한 파일명이나, 두번째 방법으로 생성한 디렉토리 이름은 웹사이트에서 고유의 주소를 갖습니다. `https://siteURL/about-javascript` 와 같이요.\r\n\r\n### 1-2. Frontmatter\r\n\r\n마크다운은 문서의 메타데이터인 Frontmatter 라 불리는 정보를 가지고 있습니다.\r\n\r\n```\r\n---\r\ntitle: \"🤔 3. 작성 가이드\"\r\ndescription: \"어떻게 글을 작성하고 추가할까요?\"\r\ndate: 2021-04-03\r\nupdate: 2021-04-03\r\ntags:\r\n  - hoodie\r\n  - writing-guide\r\nseries: \"gatsby-starter-hoodie 로 블로그 시작하기\"\r\n---\r\n```\r\n\r\n위는 지금 여러분이 읽고 있는 문서의 Frontmatter 입니다. `title` 과 `date` 는 필수 값입니다. 띄어쓰기를 포함된 문자열을 입력할 때에는 따옴표로 감싸는 것을 추천합니다.\r\n\r\n### 1-3. 마크다운 작성하기\r\n\r\n만약 Frontmatter 까지 작성했다면, 여러분은 그 아래에 마크다운 문서를 작성하면 됩니다. gatsby-starter-hoodie 는 대부분의 마크다운 문법을 지원합니다. 마크다운 작성 방법을 알고 싶다면, Github 의 [Mastering Markdown](https://guides.github.com/features/mastering-markdown/) 문서를 참고하세요.\r\n\r\n## 2. 코드 하이라이팅 & Katex\r\n\r\n### 2-1. 코드 하이라이팅\r\n\r\nPrism.JS 에 기반한 코드 하이라이팅이 제공됩니다.\r\n\r\n#### 예시\r\n\r\nJavascript\r\n\r\n```javascript\r\nconsole.log(\"Hello, world!\")\r\n```\r\n\r\nPython\r\n\r\n```python\r\nprint(\"Hello, world!\")\r\n```\r\n\r\n그 외 더 많은 언어를 제공합니다. 제공되는 언어를 확인하고 싶다면, [Prism.js 웹사이트](https://prismjs.com/) 를 참고하세요.\r\n\r\n### 2-2. Katex\r\n\r\nKatex 문법을 지원하여 복잡한 수식도 쉽게 표현할 수 있습니다.\r\n\r\n#### 인라인 모드\r\n\r\n$$E = m c^{2}$$\r\n\r\n#### 블럭 모드\r\n\r\n$$\r\n\\int_{0}^{\\infty} f(x) dx\r\n$$\r\n\r\n## 3. 글에 이미지 추가하기\r\n\r\n상대경로를 이용하여 쉽게 이미지를 추가할 수 있습니다. 디렉토리를 생성하고 그 안에 `index.md` 를 추가하여, 글을 추가하는 방법으로 작성해야 이미지 관리가 쉽습니다.\r\n\r\n![샘플 이미지 캡션](sample-image.jpg)\r\n\r\n이미지는 Lazy Loading 으로 로드되어, 빠른 초기 문서 로딩 속도를 확보할 수 있습니다.\r\n\r\n> ⚠ 이미지의 모든 확장자는 소문자여야합니다.\r\n\r\n## 4. 태그\r\n\r\n![](tag-example.jpg)\r\n\r\nFrontmatter 의 태그를 통해 쉽게 문서를 분류하고 검색할 수 있습니다. 여러분의 모든 태그는 `https://siteUrl/tags` 경로에서 확인하고, 검색할 수 있습니다.\r\n\r\n## 5. 시리즈\r\n\r\n![](series-example.jpg)\r\n\r\n여러분이 연관된 여러개의 문서를 작성할 때 시리즈를 사용할 수 있습니다. Frontmatter 에 작성된 시리즈가 같은 문서끼리 묶여 문서 상단에 리스트로 표시됩니다. 시리즈는 일련의 순서가 있는 문서들을 작성할 때 유용하게 사용할 수 있습니다. 시리즈는 문서의 작성 날짜 순서대로 정렬됩니다.\r\n\r\n현재 문서는 `gatsby-starter-hoodie 로 블로그 시작하기` 라는 시리즈로 설정되어 있습니다.\r\n"},{"excerpt":"아래 단계를 따라서 여러분의 블로그를 시작하세요. 굉장히 쉬워요 😉. 1. Gatsby 사이트 생성 컴퓨터에 node.js 와 gatsby-cli 가 설치되어 있어야합니다. 2. 개발 서버 시작 이제 localhost:8000 으로 여러분의 블로그를 접속할 수 있습니다. 3. Github 레포지토리 생성 Utterance 댓글 위젯은 Github 이슈 시…","fields":{"slug":"/quick-start-kr/"},"frontmatter":{"date":"April 02, 2021","title":"🚀 2. 빠르게 시작하기","tags":["hoodie","quick-start"]},"rawMarkdownBody":"\r\n아래 단계를 따라서 여러분의 블로그를 시작하세요. 굉장히 쉬워요 😉.\r\n\r\n## 1. Gatsby 사이트 생성\r\n\r\n> 컴퓨터에 **node.js** 와 **gatsby-cli** 가 설치되어 있어야합니다.\r\n\r\n```\r\n$ npx gatsby new my-hoodie-blog https://github.com/devHudi/gatsby-starter-hoodie\r\n```\r\n\r\n## 2. 개발 서버 시작\r\n\r\n```\r\n$ cd my-hoodie-blog\r\n$ npm run start\r\n```\r\n\r\n이제 localhost:8000 으로 여러분의 블로그를 접속할 수 있습니다.\r\n\r\n## 3. Github 레포지토리 생성\r\n\r\nUtterance 댓글 위젯은 **Github 이슈 시스템** 기반입니다. 따라서 각 블로그 별 Github 레포지토리가 필요합니다. 또한 여러분이 Github Pages 혹은 Netlify 로 블로그를 배포하길 원한다면, Github 레포지토리는 필수입니다.\r\n\r\n만약 Github 레포지토리를 생성하는 법을 모른다면, [Github 공식 문서](https://docs.github.com/en/github/getting-started-with-github/create-a-repo) 를 참조하세요.\r\n\r\n### 원격 레포지토리 등록\r\n\r\n```\r\ngit remote add origin https://github.com/{YOUR_GITHUB_NAME}/{YOUR_REPOSITORY_NAME}\r\n```\r\n\r\n## 4. blog-config.js 작성\r\n\r\n```javascript\r\nmodule.exports = {\r\n  title: \"MY BLOG\",\r\n  description: \"Hello, This is my blog\",\r\n  author: \"YOUR NAME\",\r\n  siteUrl: \"https://myblog.com\",\r\n  links: {\r\n    github: \"https://github.com\",\r\n    facebook: \"https://www.facebook.com\",\r\n    instagram: \"https://www.instagram.com\",\r\n    etc: \"https://www.google.com/\",\r\n  },\r\n  utterances: {\r\n    repo: \"{YOUR_GITHUB_NAME}/{YOUR_REPOSITORY_NAME}\",\r\n    type: \"pathname\",\r\n  },\r\n}\r\n```\r\n\r\ngatsby-starter-hoodie 는 `blog-config.js` 라는 설정 파일을 제공합니다. 이 파일에서 블로그 정보, 작성자 프로필, Utterance 설정 등을 작성할 수 있습니다. 여러분 블로그 설정에 맞게 `blog-config.js` 를 설정하세요. 하지만, `utterances.type` 속성은 수정하지 않는 것을 권장합니다.\r\n\r\n### 프로필 이미지 변경\r\n\r\n`static/profile.png` 에 위치한 이미지 파일을 원하는 이미지 파일로 교체하세요. 만약 파일명을 변경하고 싶다면, `src/components/Bio.jsx` 의 소스코드를 수정해야합니다.\r\n\r\n## 5. 포스트 추가\r\n\r\n마크다운 포스트는 `contents/posts` 경로에 위치해있습니다. 해당 경로에서 글을 작성할 수 있습니다. [여기를 클릭하여](https://devHudi.github.io/gatsby-starter-hoodie/writing-guide) 더 자세한 글 작성 방법을 확인하세요.\r\n\r\n## 6. 블로그 배포하기\r\n\r\n### 6-1 Netlify 를 통해\r\n\r\n[A Step-by-Step Guide: Gatsby on Netlify](https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/) 문서를 참조하여, Netlify 를 Github 레포지토리와 연결할 수 있습니다. 이 과정은 어렵지 않습니다.\r\n\r\nGithub 레포지토리와 연결이 되었다면, Github 레포지토리에 변경사항이 발생할 때 마다 자동으로 여러분의 블로그에 배포됩니다.\r\n\r\n### 6-2. Github Pages 를 통해\r\n\r\n#### 상황 1\r\n\r\n레포지토리 이름이 `{YOUR_GITHUB_NAME}.github.io` 형태일 경우, 아래 명령어를 실행해주세요.\r\n\r\n```\r\n$ npm run deploy-gh\r\n```\r\n\r\n#### 상황 2\r\n\r\n레포지토리 이름이 `{YOUR_GITHUB_NAME}.github.io` 형태가 아닐 경우, 아래 명령어를 실행해주세요.\r\n\r\n```\r\n$ npm run deploy-gh-prefix-paths\r\n```\r\n\r\n만약 위와 같은 경우 `gatsby-config.js` 에서 `pathPrefix` 를 여러분의 레포지토리 이름으로 바꿔야합니다.\r\n\r\n### 6-3. 다른 플랫폼\r\n\r\n```\r\n$ npm run build\r\n```\r\n\r\n위 명령어로 Gastby 웹사이트를 빌드할 수 있습니다. 빌드 결과물은 `/public` 에 저장됩니다. `/public` 디렉토리를 여러분이 사용하는 플랫폼의 배포 명령을 통해 배포해주세요.\r\n\r\n## 7. 커스터마이징\r\n\r\n### 프로젝트 구조\r\n\r\n아래 프로젝트 구조를 참고하여 커스터마이징 할 수 있습니다 🙊.\r\n\r\n```\r\n├── node_modules\r\n├── contents\r\n│   └── posts // your articles are here\r\n├── public // build outputs are here\r\n└── src\r\n    ├── assets\r\n    │   └── theme // theme config is here\r\n    ├── components\r\n    │   └── Article\r\n    │       └── Body\r\n    │           └── StyledMarkdown\r\n    │               └── index.jsx // markdown styles are here\r\n    │   ...\r\n    ├── fonts // webfonts are here\r\n    ├── hooks\r\n    ├── images\r\n    ├── pages // page components are here\r\n    ├── reducers\r\n    ├── templates // post components are here\r\n    └── utils\r\n```\r\n"},{"excerpt":"gatsby-starter-hoodie 에 대하여 gatsby-starter-hoodie 는 기술 블로그를 작성하기 위해 개발된 Gatsby 테마입니다. 마크다운과 많은 프로그래밍 언어의 코드 하이라이팅, 그리고 Katex 문법을 지원합니다. 또한 태그와 시리즈를 통하여 쉽게 게시물을 분류할 수 있습니다. 다크모드를 지원하는 깔끔한 디자인의 gatsby-…","fields":{"slug":"/about-hoodie-kr/"},"frontmatter":{"date":"April 01, 2021","title":"🎇 1. gatsby-starter-hoodie 에 대하여","tags":["hoodie","about"]},"rawMarkdownBody":"\r\n## gatsby-starter-hoodie 에 대하여\r\n\r\ngatsby-starter-hoodie 는 기술 블로그를 작성하기 위해 개발된 Gatsby 테마입니다. 마크다운과 많은 프로그래밍 언어의 코드 하이라이팅, 그리고 Katex 문법을 지원합니다. 또한 태그와 시리즈를 통하여 쉽게 게시물을 분류할 수 있습니다.\r\n\r\n다크모드를 지원하는 깔끔한 디자인의 gatsby-starter-hoodie 로 여러분의 블로그를 시작하세요.\r\n\r\n## 주요 기능\r\n\r\n- 마크다운\r\n- 코드 하이라이팅\r\n- Katex 문법\r\n- 다크모드 (OS 환경설정과 연동)\r\n- 태그 분류\r\n- 시리즈 분류\r\n- 반응형 웹\r\n- SEO\r\n- Utterance (댓글 위젯)\r\n\r\n## 시작\r\n\r\n[빠르게 시작하기](/quick-start-kr) 문서에서 블로그를 세팅하세요.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}